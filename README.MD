# Урок 1 (Введение в понятие архитектуры, проектирование ПО и жизненный цикл программного продукта. UML-диаграммы)
### Задание:
На основе Диаграмы классов ModelElements, разработать классы: Model Store, PoligonalModel (Texture, Poligon), Flash, Camera, Scene (Реализовать диограмму на любом языке программирования)

![Диаграмма](https://i.ibb.co/BcJ54zT/2023-07-21-08-02-28.png)


Решение по [этой ссылке](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Lesson_1)

# Урок 2 (Объектно-ориентированные паттерны)

**Паттерны** - это часто встречающиеся решения конкретной проблемы при проектировании архитектуры ПО.

Паттерны делятся на 3 категории:

* *Порождающие (generating)* - Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
* *Структурные (structural)* - Отвечают за построение удобных в поддержке иерархий классов.
* *Поведенческие (behavioral)* - Решают задачи эффективного и безопасного взаимодействия между объектами программы.

![Порождающие паттерны](https://i.ibb.co/Wntg2VJ/2023-07-25-08-44-34.png)

![Структурные паттерны](https://i.ibb.co/r0jm9Jc/2023-07-25-08-46-16.png)

![Поведенческие паттерны](https://i.ibb.co/pzG6dWx/2023-07-25-08-47-08.png)

***Реализация на python***:

Порождающие (generating_patterns):

* [Строитель (builder)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/builder.py)
* [Фабричный метод (factory_method)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/factory_method.py)
* [Прототип (prototip)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/prototip.py)
* [Одиночка (singlton)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/singlton.py)

Структурные (structural_patterns):

* [Компоновщик (composite)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/сomposite.py)
* [Адаптер (Adapter)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/adapter.py)
* [Мост (bridge)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/bridge.py)
* [Декоратор (decorator)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/decorator.py)
* [Фасад (facade)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/facade.py)

Поведенческие (behavioral_patterns):

* [Наблюдатель (observer)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/behavioral_patterns/observer.py)
* [Цепочка ответственности (chain of responsibility)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/chain_of_responsibility.py)
* [Команда (command)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/command.py)
* [Итератор (iterator)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/iterator.py)
* [Шаблонный метод (template_method)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/template_method.py)
* [Посетитель (visitor)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/visitor.py)

# Урок 3 (Принципы SOLID)

![Принципы SOLID](https://i.ibb.co/WgLf2g3/2023-07-27-09-49-42.png)

1. [SRP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/1_SRP) Single responsibility principle (Принцип единственной ответственности)  - Каждый класс должен выполнять строго обозначенную функцию, т.е. быть ограничен только своей задачей.

2. [OCP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/2_OCP) Open-closed principle - Принцип открытости\закрытости. Классы должны быть открыты для расширения и закрыты для модификации. Т.е. должна быть возможность добавлять новый свойства и расширять класс без изменения внутренней реализации существующих свойств.

3. [LSP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/3_LSP) Liskov substitution principle - Принцип подстановки Лескова. Подклассы должны заменять свои базовые классы. Дочерний класс должен полностью повторять функционал своего базового класса. Т.е. мы можем через дочерний класс вызвать любой метод базового класса и ожидать от него точно такого же поведения, какое у него было если мы его вызываем непосредственно из базового класса.

4.  [ISP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/4_ISP) Interface segregation principle - Принцип разделения интерфейса. Нужно создавать узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны реализовывать интерфейсы, которые они не используют. Не нужно создавать один интерфейс, реализующий много методов - т.к. все эти методы должны быть реализованы в дочерних классах, а они им могут быть не нужны. Проще создать несколько узкоспециализированных интерфейсов с одним методом для соответствующих классов.

5. [DIP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/5_DIP) Dependency inversion principle - Принцип инверсии зависимостей. Наши классы должны зависеть от интерфейсов или абстрактных классов, а не конкретных классов и функций.


# Урок 4 (Компоненты. Принципы связности и сочетаемости компонентов)

Вам необходимо доработать код, добавив контракты к методам, документацию и обеспечив высокую связанность и низкую сочетаемость:

```
// Класс для геометрических фигур
abstract class Shape {
    // Общие поля и методы для всех геометрических фигур
    abstract double getArea();
    abstract double getPerimeter();
}

// Класс для круга
class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}

// Класс для прямоугольника
class Rectangle extends Shape {
    private double length;
    private double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double getArea() {
        return length * width;
    }

    @Override
    double getPerimeter() {
        return 2 * (length + width);
    }
}

// Класс для треугольника
class Triangle extends Shape {
    private double side1;
    private double side2;
    private double side3;

    public Triangle(double side1, double side2, double side3) {
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }

    @Override
    double getArea() {
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    @Override
    double getPerimeter() {
        return side1 + side2 + side3;
    }
}

// Главный класс приложения
public class GeometryApp {
    public static void main(String[] args) {
        // Пример использования конкретных классов геометрических фигур
        Circle circle = new Circle(5.0);
        System.out.println("Площадь круга: " + circle.getArea());
        System.out.println("Периметр круга: " + circle.getPerimeter());

        Rectangle rectangle = new Rectangle(4.0, 6.0);
        System.out.println("Площадь прямоугольника: " + rectangle.getArea());
        System.out.println("Периметр прямоугольника: " + rectangle.getPerimeter());

        Triangle triangle = new Triangle(3.0, 4.0, 5.0);
        System.out.println("Площадь треугольника: " + triangle.getArea());
        System.out.println("Периметр треугольника: " + triangle.getPerimeter());
    }
}
```
[Реализация на языке Java](https://github.com/JuliaRyzhova/Software_architecture/tree/main/components_java/src) 

# Урок 5 (Горизонтальные уровни и вертикальные срезы архитектуры)

Основные паттерны доступа к данным:

1. [Data Access Object (DAO)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/DAO) - относится к слою доступа к данным в архитектуре приложения. Он предоставляет единый интерфейс для взаимодействия с базой данных или другим источником данных. Основная цель паттерна DAO - абстрагирование слоя доступа к данным от бизнес-логики приложения.

Паттерн DAO позволяет отделить код, отвечающий за работу с базой данных, от остальной части приложения. Это позволяет легко изменять базу данных или другой источник данных, не внося изменения в код других компонентов приложения. 

Сам паттерн DAO состоит из следующих компонентов:
- Интерфейс DAO: Определяет общие методы для доступа к данным, например, создание, чтение, обновление, удаление (CRUD).
- Реализация DAO: Предоставляет конкретную реализацию методов доступа к данным для конкретного источника данных, такого как база данных.
- Модель данных: Определяет классы и структуру данных, с которыми работает DAO.

Использование паттерна DAO обеспечивает четкое разделение ответственности между слоем доступа к данным и остальными компонентами приложения, что делает код более чистым, модульным и легко тестируемым.

2. [Row Data Gateway (RDG)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/RDG) - относится к слою доступа к данным в архитектуре приложения. Он предоставляет объекты, называемые «шлюзами», для взаимодействия ***с отдельными строками или записями*** базы данных. Основная цель паттерна RDG - предоставить прямой доступ к данным в таблице базы данных.

Паттерн RDG позволяет создать объект ***для каждой строки*** в таблице базы данных. Каждый объект RDG представляет отдельную запись и предоставляет методы для работы с этой записью, такие как чтение и запись значений полей.

Сам паттерн RDG состоит из следующих компонентов:
- Класс RDG: Представляет отдельную строку или запись в таблице базы данных. Класс RDG содержит методы для доступа к полям и выполнения операций над данными, таких как чтение, запись, обновление и удаление.
- Репозиторий (Repository): Это дополнительный компонент, который предоставляет доступ к коллекции объектов RDG. Репозиторий может иметь методы для получения всех записей, поиска записей на основе определенных критериев и других операций над данными.

Использование паттерна RDG позволяет упростить работу с данными в таблице базы данных. Каждый объект RDG предоставляет удобные методы для работы с отдельной записью, что делает код более читаемым и поддерживаемым. Помимо этого, использование RDG позволяет более гибко управлять операциями над данными, так как каждая запись имеет свой собственный объект.

3. [Active Record (AR)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/AR) - относится к слою доступа к данным в архитектуре приложения. Он представляет отдельную запись базы данных как объект, называемый "активной записью", и предоставляет методы для работы с этой записью. Основная цель паттерна Active Record - упростить и удобно организовать работу с данными в базе данных.

Паттерн Active Record позволяет работать с записью в базе данных как с объектом. Каждая активная запись имеет свои поля (атрибуты) и методы для чтения, записи и обновления значений полей, а также для выполнения других операций с записью (например, удаление или поиск).

Сам паттерн Active Record состоит из следующих компонентов:
- Класс Active Record: Представляет отдельную запись в базе данных как объект. Класс Active Record содержит поля (атрибуты), которые соответствуют полям записи в базе данных, а также методы для доступа к этим полям. Класс Active Record также может содержать методы для выполнения операций над записью, такие как сохранение (создание новой записи или обновление существующей), удаление и поиск.
- Репозиторий (Repository): Это дополнительный компонент, который предоставляет доступ к коллекции объектов Active Record. Репозиторий может иметь методы для получения всех записей, поиска записей на основе определенных критериев и других операций над данными.

Использование паттерна Active Record упрощает работу с записями в базе данных. Каждая активная запись представляется в виде объекта, что делает код более понятным и легким в поддержке. Кроме того, использование Active Record позволяет удобно выполнять операции с данными, так как каждая запись имеет свои методы для работы с ней.

**Отличия между паттернами Active Rercord и Road Data GateWAy:**

1. Организация данных: 
   - В Active Record каждая запись базы данных представлена отдельным объектом, который содержит поля (атрибуты) записи и методы для работы с ними.
   - В RDG каждая строка или запись базы данных представлена отдельным объектом, который предоставляет методы для доступа к значениям полей, но не содержит собственных полей.

2. Зависимость от таблицы:
   - В Active Record каждый объект Active Record связан с определенной таблицей базы данных. Это означает, что изменения в структуре таблицы могут потребовать изменений в классе Active Record.
   - В RDG каждый объект RDG может работать с разными таблицами базы данных без изменения своей структуры.

3. Взаимодействие с базой данных:
   - В Active Record объекты Active Record непосредственно взаимодействуют с базой данных, выполняя операции чтения, записи, обновления и удаления.
   - В RDG объекты RDG делают запросы к базе данных через отдельный компонент, называемый репозиторием, который предоставляет методы для доступа к данным.

4. [Table Data Gateway (TDG)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/TDG) -  относится к слою доступа к данным в архитектуре приложения. Он предоставляет интерфейс для выполнения операций с таблицей базы данных. Основная цель паттерна TDG - упростить и стандартизировать работу с данными таблицы базы данных.

Простыми словами, паттерн TDG представляет собой объект, называемый "шлюзом таблицы", который предоставляет методы для выполнения операций с таблицей базы данных, таких как чтение, запись, обновление и удаление. Вместо того, чтобы вносить разные запросы в базу данных из разных мест в приложении, все операции с данными выполняются через единый объект TDG.

Сам паттерн TDG состоит из следующих компонентов:
- Класс TDG: Определяет интерфейс для выполнения операций с таблицей базы данных, таких как чтение, запись, обновление и удаление. Класс TDG может также содержать реализацию этих операций.
- Репозиторий (Repository): Это дополнительный компонент, который предоставляет доступ к объектам TDG. Репозиторий может иметь методы для получения объекта TDG, выполнения операций с данными и других операций над таблицей.

Использование паттерна TDG упрощает работу с таблицей базы данных. Все операции с данными выполняются через единый объект TDG, что делает код более структурированным и читаемым. Кроме того, использование TDG позволяет легко менять запросы к базе данных или саму базу данных без внесения изменений в другие части приложения.

**Отличия между паттернами Table Data GateWay и Road Data GAteWay:**

1. Организация данных:
   - TDG: В паттерне TDG, данные о таблицах и операциях с базой данных хранятся в отдельном классе-шлюзе (Gateway), который предоставляет методы для работы с конкретной таблицей. Каждая таблица имеет свой собственный шлюз.
   - RDG: В паттерне RDG, данные о каждой конкретной записи хранятся в собственном объекте-шлюзе (Gateway), который предоставляет методы для работы с этой записью. Каждый объект-шлюз соответствует одной записи в таблице.

2. Зависимость от таблицы:
   - TDG: В паттерне TDG, класс-шлюз зависит от конкретной таблицы, поскольку предоставляет методы для работы только с этой таблицей.
   - RDG: В паттерне RDG, класс-шлюз также зависит от конкретной таблицы, так как предоставляет методы для работы с данной записью в таблице.

3. Взаимодействие с базой данных:
   - TDG: В паттерне TDG, каждый метод класса-шлюза выполняет отдельный SQL-запрос для получения, вставки, обновления или удаления данных в таблице. Имеется возможность использования собственных запросов для каждой операции.
   - RDG: В паттерне RDG, класс-шлюз также выполняет отдельные SQL-запросы, но обычно операции выполняются на уровне объекта, а не на уровне таблицы. Например, метод для сохранения записи в базе данных будет использовать INSERT-запрос для вставки новой записи.

Оба паттерна предоставляют абстракцию для работы с базой данных, но они различаются в организации данных и способах выполнения операций с базой данных. 

5. [Repository](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/Repository) - представляет собой способ организации доступа к данным в приложении. Он обеспечивает абстракцию между бизнес-логикой и источником данных (например, базой данных), чтобы разделить ответственность за доступ к данным от остальных частей приложения.

Например, у нас есть приложение, которое работает с пользователями. Репозиторий пользователей будет иметь методы для сохранения, обновления, удаления и получения информации о пользователях. Вместо того чтобы размещать код доступа к базе данных прямо в бизнес-логике, можно использовать репозиторий пользователей, чтобы абстрагироваться от деталей доступа к данным.

Таким образом, паттерн Repository обеспечивает единый интерфейс для работы с данными, который скрывает сложности работы с базой данных или другими источниками данных. Это позволяет легко изменить источник данных в будущем или добавить новую функциональность без необходимости изменять ту часть кода, которая зависит от репозитория.

В итоге, паттерн Repository помогает упростить код приложения, повышает его гибкость и улучшает возможности тестирования бизнес-логики.

![UML-диаграмма компонентов паттерна Repository](https://i.ibb.co/1KfjTck/Untitled-2.jpg)


![Сравнительная таблица паттернов](https://i.ibb.co/Vqrvzjk/2023-08-07-10-23-10.png)

# Урок 6 (Принципы построения приложений «чистая архитектура)

![Критерии чистой архитектуры](https://i.ibb.co/FbN5KZs/2023-08-08-14-47-58.png)

![Расположение модулей проекта](https://i.ibb.co/8gTGG1B/2023-08-08-14-49-41.png)

[Пример реализации принципов Чистой архитектуры на Java](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_6_java/src/boundary_control_entity)

### Задание 
Задание: Переделка программы под чистую архитектуру

Вам предоставляется программа, которая представляет интернет-магазин книг с использованием коллекций. Ваша задача - переработать эту программу, применяя принципы чистой архитектуры для лучшей организации кода и разделения компонентов. В результате переработки программа должна следовать принципам Boundary-Control-Entity (BCE).

Требования:

Создайте пакеты domain, data, и presentation.

В пакете domain создайте классы, представляющие бизнес-объекты интернет-магазина книг. Например, Book - представляющий модель книги.

В пакете data создайте интерфейс BookRepository, определяющий методы для управления книгами в интернет-магазине. Затем реализуйте этот интерфейс в классе InMemoryBookRepository, используя коллекции для хранения данных о книгах.

В пакете presentation создайте класс Main, который будет представлять точку входа в приложение и обрабатывать пользовательские запросы.

Используйте принципы чистой архитектуры для организации компонентов (BCE). Каждый компонент должен быть отделен от других, взаимодействие должно происходить через абстракции, а не через конкретные реализации.

Перенесите функциональность работы с коллекциями и хранения данных в пакет data, таким образом, чтобы она не проникала в другие компоненты.

Обеспечьте возможность добавления, удаления и получения списка книг через интерфейс BookRepository, а затем используйте его в Main для управления книгами.

Убедитесь, что код программы чистый, читаемый и хорошо структурированный. Обеспечьте надлежащее разделение ответственности между компонентами и минимизируйте повторяющийся код.

Примечание:

Данный код предоставлен только для ознакомления с исходной реализацией и не представляет полный функционал интернет-магазина книг. Ваша задача - переработать его согласно принципам чистой архитектуры и обеспечить соответствующий функционал.

**
Вот пример кода, представляющего интернет-магазин книг с использованием коллекций, но без реализации чистой архитектуры:

```
import java.util.ArrayList;
import java.util.List;

// Класс представляющий книгу
class Book {
    private String id;
    private String title;
    private String author;
    private double price;

    // Конструктор, геттеры и сеттеры
}

// Класс, реализующий хранилище книг с использованием коллекций
class BookStore {
    private List<Book> books;

    public BookStore() {
        books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
    }

    public void removeBook(Book book) {
        books.remove(book);
    }

    public List<Book> getAllBooks() {
        return books;
    }
}

public class Main {
    public static void main(String[] args) {
        BookStore bookStore = new BookStore();

        // Добавляем книги в магазин
        Book book1 = new Book("1", "Clean Code", "Robert C. Martin", 34.99);
        Book book2 = new Book("2", "Effective Java", "Joshua Bloch", 29.99);
        bookStore.addBook(book1);
        bookStore.addBook(book2);

        // Получаем список всех книг в магазине
        List<Book> allBooks = bookStore.getAllBooks();
        for (Book book : allBooks) {
            System.out.println("Книга: " + book.getTitle() + ", Автор: " + book.getAuthor() + ", Цена: $" + book.getPrice());
        }
    }
}

```

[Реализация принципов Чистой архитектуры на Python](https://github.com/JuliaRyzhova/Software_architecture/tree/main/clean_architecture_python)


# Урок 7 (Типа архитектур WEB-приложений: MPA, SPA.)

Задание:

Описать этапы подготовки к разработке вэб-приложения, сделайть сырой макет интерфейса на figma.com

[Реализация ](https://github.com/JuliaRyzhova/Software_architecture/blob/main/web_application/README.md)


# Урок 8 (Типы архитектур прикладных приложений (мобильные): MVC, MVP, MVVM)
[Реализация паттернов на языке Java](https://github.com/JuliaRyzhova/Software_architecture/tree/main/seminar_8_java/src)

Задание:

Задание: Создание UML диаграммы классов для веб-приложения(Любого, но лучше взять за основу предыдущее)

[Реализация ](https://github.com/JuliaRyzhova/Software_architecture/blob/main/uml_diagram/README.md)

# Урок 9 (Способы организации передачи данных между компонентами приложения, протоколы и API. REST, gRPC, очереди)
Домашнее задание: Разработка и тестирование RESTful API на Python

Цель: Дать студентам практический опыт создания и тестирования RESTful API.

Задачи:
1. Разработать простой RESTful API для сущности "Книга" на Python.
2. Провести базовое тестирование созданного API, используя инструменты Python.

Подробная инструкция:

1. Разработка RESTful API для сущности "Книга" на Python
a. Определение модели "Книга":
- Определите атрибуты для книги: например, ID, название, автор, год издания и т.д.

b. Создание API с использованием Flask:
- Установите Flask (если он еще не установлен): pip install Flask.
- Создайте новый файл Python, например app.py.
- Импортируйте необходимые библиотеки и определите экземпляр приложения Flask.
- Определите маршруты и обработчики для базовых CRUD операций:
- POST /books - добавить новую книгу.
- GET /books - получить список всех книг.
- GET /books/<int:id> - получить информацию о конкретной книге по ID.
- PUT /books/<int:id> - обновить информацию о книге.
- DELETE /books/<int:id> - удалить книгу.

Подсказка: Для сохранения данных во временной базе, вы можете использовать структуры данных Python, например, список словарей.

2. Тестирование API с использованием инструментов Python - По желанию
a. Подготовка к тестированию:

Запустите ваше приложение Flask: python app.py.
Удостоверьтесь, что ваш сервер работает и слушает соответствующий порт (обычно 5000).
b. Базовое тестирование CRUD операций с использованием requests:
- Установите библиотеку requests, если она ещё не установлена: pip install requests.
- Создайте новый файл Python для тестирования, например, test_app.py.
- Импортируйте requests и напишите функции тестирования для каждой CRUD операции, отправляя запросы к вашему API и проверяя ответы.

Подсказка: Проверяйте статусы ответов, а также содержание ответов (например, при добавлении новой книги проверьте, что она действительно добавлена в список).

[Реализация приложения с использованием фреймворка Flask и БД SQLite, можно запустить и посмотреть результат через локалхост ](https://github.com/JuliaRyzhova/Software_architecture/tree/main/restfull_api/flaskr)


# Урок 10 (Структура приложения с пользовательским интерфейсом и базой данных (паттерн Repository))

Задание:

Вы можете реализовать эти патерны, в рамках своего проекта, к которому Вы делали диограммы и таблицы. Или реализовать отдельно от них.
Домашнее задание: Реализация паттернов Агрегатор, Репозиторий и Кеширования
Цель: Освоить принципы работы и применение трёх ключевых паттернов проектирования: Агрегатор, Репозиторий и Кеширование.

Часть 1: Паттерн Агрегатор
Реализуйте классы Order, OrderItem и Product.
Order должен содержать список OrderItem, каждый из которых содержит Product и количество этого продукта.
У каждого заказа должен быть метод для расчета общей стоимости.
Часть 2: Паттерн Репозиторий
Создайте интерфейс OrderRepository, который определяет методы для работы с заказами (сохранение, загрузка по ID, загрузка всех заказов и т. д.).
Реализуйте класс OrderRepositoryImpl, который реализует данный интерфейс, используя любую базу данных на ваш выбор (может быть встроенной, например, SQLite).
В репозитории обеспечьте сохранение и загрузку заказов, а также всех связанных с ними объектов (OrderItem, Product).
Часть 3: Паттерн Кеширования
Исследуйте и выберите одну из библиотек для кеширования в Java (например, EhCache, Caffeine или Guava Cache).
Реализуйте кеширование в вашем репозитории таким образом, чтобы часто запрашиваемые заказы загружались из кэша, а не из базы данных.
Обеспечьте инвалидацию кэша (обновление данных в кэше), если информация в базе данных была изменена.
Дополнительное задание:
Реализуйте пользовательский интерфейс (может быть консольным или графическим), чтобы демонстрировать создание, редактирование, загрузку и удаление заказов.
Добавьте возможность фильтрации и сортировки заказов при их загрузке из базы данных.
Советы:

Соблюдайте принципы SOLID при проектировании и реализации вашего приложения.
Обрабатывайте все возможные исключения, особенно при работе с базой данных.
Подумайте над оптимальной стратегией кеширования в зависимости от предполагаемого объема данных и частоты запросов.
Это задание предполагает разработку приложения с использованием трёх ключевых паттернов

[Реализация на python](https://github.com/JuliaRyzhova/Software_architecture/tree/main/app_with_ui)

# Урок 11 (Сервис-ориентированные архитектуры)

Задание:

Расширяем наш проект
Была одна главная страница- делаем наброски для друг страниц(Заказ, доставка, и т д в зависимости от темы . Пример - https://stealth-force-e00.notion.site/f38d6a54d65542fd97f8fc39aba36758?pvs=4). Вы это делаете для дизайнера, можно сделать и в пейнт, не надо тратить на это много время . https://www.figma.com/
Расширяем диограммы.
Пример на основе приложения для робота-пылесоса - https://geekbrainspro.notion.site/2-11-1b0361e053584d5db3f09064ef90cf2d

__
UML-диаграмма пакетов:
__
Пакеты и подсистемы: Показывает структуру пакетов и их взаимосвязи. Пакеты могут содержать классы, интерфейсы, диаграммы и другие элементы.
Отношения между пакетами: Диаграмма может показать, как пакеты связаны друг с другом, например, зависимости или ассоциации.
__
UML-диаграмма системы обновления приложения:
__
Компоненты и связи: Показывает компоненты, связанные с обновлением приложения, такие как "Клиентское приложение", "Сервер обновлений", "База данных версий".
Поток данных: Может включать поток данных от клиентского приложения к серверу обновлений и обратно.
__
UML-диаграмма домена (Domain Diagram):
__
Сущности и связи: Диаграмма домена обычно представляет ключевые сущности в системе и связи между ними. Это может быть базовая структура данных, которая влияет на всю систему.
Атрибуты: Диаграмма может также включать атрибуты, которые описывают каждую сущность.
Системы и компоненты: Если система состоит из различных подсистем или компонентов, они также могут быть показаны
__
UML-диаграмма системы обновления приложения:

Компоненты и связи: Показывает компоненты, связанные с обновлением приложения, такие как "Клиентское приложение", "Сервер обновлений", "База данных версий".
Поток данных: Может включать поток данных от клиентского приложения к серверу обновлений и обратно.

__
__
__
__

По желанию, но крайне рекомендуется добавить к своему проекту.
Спроектировать слой  API Gateway (mobile, web), сформировать REST запросы: GET, POST, PUT, DELETE (https://swagger.io).
Предположим, у вас есть простой API для управления списком пользователей. Вам нужно описать запрос типа GET, который вернет список всех пользователей.
__
Откройте Swagger: Перейдите на сайт https://swagger.io и, возможно, создайте новую спецификацию или проект, чтобы начать описание вашего API.
__
__
Описание запроса GET:
Определите функциональность API Gateway:
__
Определите, какие функции будет выполнять ваш API Gateway. Например, это может быть маршрутизация запросов от мобильных устройств и веб-клиентов к соответствующим микросервисам.
Выберите инструмент Swagger:
__
Откройте инструмент Swagger (https://swagger.io) или его альтернативы, которые позволяют создавать и документировать API.
Создайте новую спецификацию:
__
Если используете Swagger, создайте новую спецификацию (или проект) для вашего API Gateway.
Определите эндпоинты:
__
Определите список эндпоинтов (URL-путей), которые будут доступны через ваш API Gateway. Например, /mobile и /web.
Сформируйте запросы:
__
Для каждого эндпоинта, определите HTTP-методы, которые он поддерживает (GET, POST, PUT, DELETE).
Опишите запросы:
__
Для каждого метода опишите, какие параметры (если есть) должны быть переданы в запросе, а также форматы данных запроса и ответа.
Пример запроса:
__
Предоставьте пример запроса для каждого метода, чтобы пользователи могли понять, как правильно формировать запросы.
Форматы данных:
__
Укажите, какой формат данных (обычно JSON) используется для передачи данных между клиентами и API Gateway.
Генерируйте документацию:
__
Используйте возможности инструмента Swagger для автоматической генерации документации на основе вашей спецификации. Документация должна быть понятной и информативной.
Тестирование:
__
Используйте инструмент Swagger или другие инструменты для тестирования запросов на вашем API Gateway. Убедитесь, что запросы выполняются корректно.
Документация и доступность:
__
Предоставьте ссылку на документацию вашего API Gateway. Удостоверьтесь, что другие разработчики и клиенты смогут получить доступ к этой документации.

__
Помните, что проектирование API Gateway - это описание, как клиенты (мобильные приложения, веб-приложения и т.д.) будут взаимодействовать с вашей системой через единый входной точки. Swagger поможет вам создать четкую документацию, которая упростит интеграцию с вашим API Gateway.

Пример выполнения - https://stealth-force-e00.notion.site/289383d7b8b3424f911c04b25d722c80?pvs=4
__
Задача Swagger - упростить процесс описания и документирования вашего API, а также предоставить средства для тестирования API непосредственно из документации.

[Реализация](https://github.com/JuliaRyzhova/Software_architecture/tree/main/lesson_11)

# Урок 12 (Принципы тестирования приложений)

Задание: Написать документацию к тестированию для интернет магазина

[Реализация](https://github.com/JuliaRyzhova/Software_architecture/tree/main/tests)