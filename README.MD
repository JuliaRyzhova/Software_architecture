# Урок 1 (Введение в понятие архитектуры, проектирование ПО и жизненный цикл программного продукта. UML-диаграммы)
### Задание:
На основе Диаграмы классов ModelElements, разработать классы: Model Store, PoligonalModel (Texture, Poligon), Flash, Camera, Scene (Реализовать диограмму на любом языке программирования)

![Диаграмма](https://i.ibb.co/BcJ54zT/2023-07-21-08-02-28.png)


Решение по [этой ссылке](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Lesson_1)

# Урок 2 (Объектно-ориентированные паттерны)

**Паттерны** - это часто встречающиеся решения конкретной проблемы при проектировании архитектуры ПО.

Паттерны делятся на 3 категории:

* *Порождающие (generating)* - Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
* *Структурные (structural)* - Отвечают за построение удобных в поддержке иерархий классов.
* *Поведенческие (behavioral)* - Решают задачи эффективного и безопасного взаимодействия между объектами программы.

![Порождающие паттерны](https://i.ibb.co/Wntg2VJ/2023-07-25-08-44-34.png)

![Структурные паттерны](https://i.ibb.co/r0jm9Jc/2023-07-25-08-46-16.png)

![Поведенческие паттерны](https://i.ibb.co/pzG6dWx/2023-07-25-08-47-08.png)

***Реализация на python***:

Порождающие (generating_patterns):

* [Строитель (builder)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/builder.py)
* [Фабричный метод (factory_method)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/factory_method.py)
* [Прототип (prototip)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/prototip.py)
* [Одиночка (singlton)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/generating_patterns/singlton.py)

Структурные (structural_patterns):

* [Компоновщик (composite)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/сomposite.py)
* [Адаптер (Adapter)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/adapter.py)
* [Мост (bridge)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/bridge.py)
* [Декоратор (decorator)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/decorator.py)
* [Фасад (facade)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/structural_patterns/facade.py)

Поведенческие (behavioral_patterns):

* [Наблюдатель (observer)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/Seminar_2/behavioral_patterns/observer.py)
* [Цепочка ответственности (chain of responsibility)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/chain_of_responsibility.py)
* [Команда (command)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/command.py)
* [Итератор (iterator)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/iterator.py)
* [Шаблонный метод (template_method)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/template_method.py)
* [Посетитель (visitor)](https://github.com/JuliaRyzhova/Software_architecture/blob/main/OOP_patterns/behavioral_patterns/visitor.py)

# Урок 3 (Принципы SOLID)

![Принципы SOLID](https://i.ibb.co/WgLf2g3/2023-07-27-09-49-42.png)

1. [SRP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/1_SRP) Single responsibility principle (Принцип единственной ответственности)  - Каждый класс должен выполнять строго обозначенную функцию, т.е. быть ограничен только своей задачей.

2. [OCP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/2_OCP) Open-closed principle - Принцип открытости\закрытости. Классы должны быть открыты для расширения и закрыты для модификации. Т.е. должна быть возможность добавлять новый свойства и расширять класс без изменения внутренней реализации существующих свойств.

3. [LSP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/3_LSP) Liskov substitution principle - Принцип подстановки Лескова. Подклассы должны заменять свои базовые классы. Дочерний класс должен полностью повторять функционал своего базового класса. Т.е. мы можем через дочерний класс вызвать любой метод базового класса и ожидать от него точно такого же поведения, какое у него было если мы его вызываем непосредственно из базового класса.

4.  [ISP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/4_ISP) Interface segregation principle - Принцип разделения интерфейса. Нужно создавать узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны реализовывать интерфейсы, которые они не используют. Не нужно создавать один интерфейс, реализующий много методов - т.к. все эти методы должны быть реализованы в дочерних классах, а они им могут быть не нужны. Проще создать несколько узкоспециализированных интерфейсов с одним методом для соответствующих классов.

5. [DIP](https://github.com/JuliaRyzhova/Software_architecture/blob/main/SOLID/5_DIP) Dependency inversion principle - Принцип инверсии зависимостей. Наши классы должны зависеть от интерфейсов или абстрактных классов, а не конкретных классов и функций.


# Урок 4 (Компоненты. Принципы связности и сочетаемости компонентов)

Вам необходимо доработать код, добавив контракты к методам, документацию и обеспечив высокую связанность и низкую сочетаемость:

```
// Класс для геометрических фигур
abstract class Shape {
    // Общие поля и методы для всех геометрических фигур
    abstract double getArea();
    abstract double getPerimeter();
}

// Класс для круга
class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}

// Класс для прямоугольника
class Rectangle extends Shape {
    private double length;
    private double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    double getArea() {
        return length * width;
    }

    @Override
    double getPerimeter() {
        return 2 * (length + width);
    }
}

// Класс для треугольника
class Triangle extends Shape {
    private double side1;
    private double side2;
    private double side3;

    public Triangle(double side1, double side2, double side3) {
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }

    @Override
    double getArea() {
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    @Override
    double getPerimeter() {
        return side1 + side2 + side3;
    }
}

// Главный класс приложения
public class GeometryApp {
    public static void main(String[] args) {
        // Пример использования конкретных классов геометрических фигур
        Circle circle = new Circle(5.0);
        System.out.println("Площадь круга: " + circle.getArea());
        System.out.println("Периметр круга: " + circle.getPerimeter());

        Rectangle rectangle = new Rectangle(4.0, 6.0);
        System.out.println("Площадь прямоугольника: " + rectangle.getArea());
        System.out.println("Периметр прямоугольника: " + rectangle.getPerimeter());

        Triangle triangle = new Triangle(3.0, 4.0, 5.0);
        System.out.println("Площадь треугольника: " + triangle.getArea());
        System.out.println("Периметр треугольника: " + triangle.getPerimeter());
    }
}
```
[Реализация на языке Java](https://github.com/JuliaRyzhova/Software_architecture/tree/main/components_java/src) 

# Урок 5 (Горизонтальные уровни и вертикальные срезы архитектуры)

Основные паттерны доступа к данным:

1. [Data Access Object (DAO)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/DAO) - относится к слою доступа к данным в архитектуре приложения. Он предоставляет единый интерфейс для взаимодействия с базой данных или другим источником данных. Основная цель паттерна DAO - абстрагирование слоя доступа к данным от бизнес-логики приложения.

Паттерн DAO позволяет отделить код, отвечающий за работу с базой данных, от остальной части приложения. Это позволяет легко изменять базу данных или другой источник данных, не внося изменения в код других компонентов приложения. 

Сам паттерн DAO состоит из следующих компонентов:
- Интерфейс DAO: Определяет общие методы для доступа к данным, например, создание, чтение, обновление, удаление (CRUD).
- Реализация DAO: Предоставляет конкретную реализацию методов доступа к данным для конкретного источника данных, такого как база данных.
- Модель данных: Определяет классы и структуру данных, с которыми работает DAO.

Использование паттерна DAO обеспечивает четкое разделение ответственности между слоем доступа к данным и остальными компонентами приложения, что делает код более чистым, модульным и легко тестируемым.

2. [Row Data Gateway (RDG)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/RDG) - относится к слою доступа к данным в архитектуре приложения. Он предоставляет объекты, называемые «шлюзами», для взаимодействия ***с отдельными строками или записями*** базы данных. Основная цель паттерна RDG - предоставить прямой доступ к данным в таблице базы данных.

Паттерн RDG позволяет создать объект ***для каждой строки*** в таблице базы данных. Каждый объект RDG представляет отдельную запись и предоставляет методы для работы с этой записью, такие как чтение и запись значений полей.

Сам паттерн RDG состоит из следующих компонентов:
- Класс RDG: Представляет отдельную строку или запись в таблице базы данных. Класс RDG содержит методы для доступа к полям и выполнения операций над данными, таких как чтение, запись, обновление и удаление.
- Репозиторий (Repository): Это дополнительный компонент, который предоставляет доступ к коллекции объектов RDG. Репозиторий может иметь методы для получения всех записей, поиска записей на основе определенных критериев и других операций над данными.

Использование паттерна RDG позволяет упростить работу с данными в таблице базы данных. Каждый объект RDG предоставляет удобные методы для работы с отдельной записью, что делает код более читаемым и поддерживаемым. Помимо этого, использование RDG позволяет более гибко управлять операциями над данными, так как каждая запись имеет свой собственный объект.

3. [Active Record (AR)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/AR) - относится к слою доступа к данным в архитектуре приложения. Он представляет отдельную запись базы данных как объект, называемый "активной записью", и предоставляет методы для работы с этой записью. Основная цель паттерна Active Record - упростить и удобно организовать работу с данными в базе данных.

Паттерн Active Record позволяет работать с записью в базе данных как с объектом. Каждая активная запись имеет свои поля (атрибуты) и методы для чтения, записи и обновления значений полей, а также для выполнения других операций с записью (например, удаление или поиск).

Сам паттерн Active Record состоит из следующих компонентов:
- Класс Active Record: Представляет отдельную запись в базе данных как объект. Класс Active Record содержит поля (атрибуты), которые соответствуют полям записи в базе данных, а также методы для доступа к этим полям. Класс Active Record также может содержать методы для выполнения операций над записью, такие как сохранение (создание новой записи или обновление существующей), удаление и поиск.
- Репозиторий (Repository): Это дополнительный компонент, который предоставляет доступ к коллекции объектов Active Record. Репозиторий может иметь методы для получения всех записей, поиска записей на основе определенных критериев и других операций над данными.

Использование паттерна Active Record упрощает работу с записями в базе данных. Каждая активная запись представляется в виде объекта, что делает код более понятным и легким в поддержке. Кроме того, использование Active Record позволяет удобно выполнять операции с данными, так как каждая запись имеет свои методы для работы с ней.

**Отличия между паттернами Active Rercord и Road Data GateWAy:**

1. Организация данных: 
   - В Active Record каждая запись базы данных представлена отдельным объектом, который содержит поля (атрибуты) записи и методы для работы с ними.
   - В RDG каждая строка или запись базы данных представлена отдельным объектом, который предоставляет методы для доступа к значениям полей, но не содержит собственных полей.

2. Зависимость от таблицы:
   - В Active Record каждый объект Active Record связан с определенной таблицей базы данных. Это означает, что изменения в структуре таблицы могут потребовать изменений в классе Active Record.
   - В RDG каждый объект RDG может работать с разными таблицами базы данных без изменения своей структуры.

3. Взаимодействие с базой данных:
   - В Active Record объекты Active Record непосредственно взаимодействуют с базой данных, выполняя операции чтения, записи, обновления и удаления.
   - В RDG объекты RDG делают запросы к базе данных через отдельный компонент, называемый репозиторием, который предоставляет методы для доступа к данным.

4. [Table Data Gateway (TDG)](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/TDG) -  относится к слою доступа к данным в архитектуре приложения. Он предоставляет интерфейс для выполнения операций с таблицей базы данных. Основная цель паттерна TDG - упростить и стандартизировать работу с данными таблицы базы данных.

Простыми словами, паттерн TDG представляет собой объект, называемый "шлюзом таблицы", который предоставляет методы для выполнения операций с таблицей базы данных, таких как чтение, запись, обновление и удаление. Вместо того, чтобы вносить разные запросы в базу данных из разных мест в приложении, все операции с данными выполняются через единый объект TDG.

Сам паттерн TDG состоит из следующих компонентов:
- Класс TDG: Определяет интерфейс для выполнения операций с таблицей базы данных, таких как чтение, запись, обновление и удаление. Класс TDG может также содержать реализацию этих операций.
- Репозиторий (Repository): Это дополнительный компонент, который предоставляет доступ к объектам TDG. Репозиторий может иметь методы для получения объекта TDG, выполнения операций с данными и других операций над таблицей.

Использование паттерна TDG упрощает работу с таблицей базы данных. Все операции с данными выполняются через единый объект TDG, что делает код более структурированным и читаемым. Кроме того, использование TDG позволяет легко менять запросы к базе данных или саму базу данных без внесения изменений в другие части приложения.

**Отличия между паттернами Table Data GateWay и Road Data GAteWay:**

1. Организация данных:
   - TDG: В паттерне TDG, данные о таблицах и операциях с базой данных хранятся в отдельном классе-шлюзе (Gateway), который предоставляет методы для работы с конкретной таблицей. Каждая таблица имеет свой собственный шлюз.
   - RDG: В паттерне RDG, данные о каждой конкретной записи хранятся в собственном объекте-шлюзе (Gateway), который предоставляет методы для работы с этой записью. Каждый объект-шлюз соответствует одной записи в таблице.

2. Зависимость от таблицы:
   - TDG: В паттерне TDG, класс-шлюз зависит от конкретной таблицы, поскольку предоставляет методы для работы только с этой таблицей.
   - RDG: В паттерне RDG, класс-шлюз также зависит от конкретной таблицы, так как предоставляет методы для работы с данной записью в таблице.

3. Взаимодействие с базой данных:
   - TDG: В паттерне TDG, каждый метод класса-шлюза выполняет отдельный SQL-запрос для получения, вставки, обновления или удаления данных в таблице. Имеется возможность использования собственных запросов для каждой операции.
   - RDG: В паттерне RDG, класс-шлюз также выполняет отдельные SQL-запросы, но обычно операции выполняются на уровне объекта, а не на уровне таблицы. Например, метод для сохранения записи в базе данных будет использовать INSERT-запрос для вставки новой записи.

Оба паттерна предоставляют абстракцию для работы с базой данных, но они различаются в организации данных и способах выполнения операций с базой данных. 

5. [Repository](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_5/Repository) - представляет собой способ организации доступа к данным в приложении. Он обеспечивает абстракцию между бизнес-логикой и источником данных (например, базой данных), чтобы разделить ответственность за доступ к данным от остальных частей приложения.

Например, у нас есть приложение, которое работает с пользователями. Репозиторий пользователей будет иметь методы для сохранения, обновления, удаления и получения информации о пользователях. Вместо того чтобы размещать код доступа к базе данных прямо в бизнес-логике, можно использовать репозиторий пользователей, чтобы абстрагироваться от деталей доступа к данным.

Таким образом, паттерн Repository обеспечивает единый интерфейс для работы с данными, который скрывает сложности работы с базой данных или другими источниками данных. Это позволяет легко изменить источник данных в будущем или добавить новую функциональность без необходимости изменять ту часть кода, которая зависит от репозитория.

В итоге, паттерн Repository помогает упростить код приложения, повышает его гибкость и улучшает возможности тестирования бизнес-логики.

![UML-диаграмма компонентов паттерна Repository](https://i.ibb.co/1KfjTck/Untitled-2.jpg)


![Сравнительная таблица паттернов](https://i.ibb.co/Vqrvzjk/2023-08-07-10-23-10.png)

# Урок 6 (Принципы построения приложений «чистая архитектура)

![Критерии чистой архитектуры](https://i.ibb.co/FbN5KZs/2023-08-08-14-47-58.png)

![Расположение модулей проекта](https://i.ibb.co/8gTGG1B/2023-08-08-14-49-41.png)

[Пример реализации принципов Чистой архитектуры на Java](https://github.com/JuliaRyzhova/Software_architecture/tree/main/Seminar_6_java/src/boundary_control_entity)

### Задание 
Задание: Переделка программы под чистую архитектуру

Вам предоставляется программа, которая представляет интернет-магазин книг с использованием коллекций. Ваша задача - переработать эту программу, применяя принципы чистой архитектуры для лучшей организации кода и разделения компонентов. В результате переработки программа должна следовать принципам Boundary-Control-Entity (BCE).

Требования:

Создайте пакеты domain, data, и presentation.

В пакете domain создайте классы, представляющие бизнес-объекты интернет-магазина книг. Например, Book - представляющий модель книги.

В пакете data создайте интерфейс BookRepository, определяющий методы для управления книгами в интернет-магазине. Затем реализуйте этот интерфейс в классе InMemoryBookRepository, используя коллекции для хранения данных о книгах.

В пакете presentation создайте класс Main, который будет представлять точку входа в приложение и обрабатывать пользовательские запросы.

Используйте принципы чистой архитектуры для организации компонентов (BCE). Каждый компонент должен быть отделен от других, взаимодействие должно происходить через абстракции, а не через конкретные реализации.

Перенесите функциональность работы с коллекциями и хранения данных в пакет data, таким образом, чтобы она не проникала в другие компоненты.

Обеспечьте возможность добавления, удаления и получения списка книг через интерфейс BookRepository, а затем используйте его в Main для управления книгами.

Убедитесь, что код программы чистый, читаемый и хорошо структурированный. Обеспечьте надлежащее разделение ответственности между компонентами и минимизируйте повторяющийся код.

Примечание:

Данный код предоставлен только для ознакомления с исходной реализацией и не представляет полный функционал интернет-магазина книг. Ваша задача - переработать его согласно принципам чистой архитектуры и обеспечить соответствующий функционал.

**
Вот пример кода, представляющего интернет-магазин книг с использованием коллекций, но без реализации чистой архитектуры:

```
import java.util.ArrayList;
import java.util.List;

// Класс представляющий книгу
class Book {
    private String id;
    private String title;
    private String author;
    private double price;

    // Конструктор, геттеры и сеттеры
}

// Класс, реализующий хранилище книг с использованием коллекций
class BookStore {
    private List<Book> books;

    public BookStore() {
        books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
    }

    public void removeBook(Book book) {
        books.remove(book);
    }

    public List<Book> getAllBooks() {
        return books;
    }
}

public class Main {
    public static void main(String[] args) {
        BookStore bookStore = new BookStore();

        // Добавляем книги в магазин
        Book book1 = new Book("1", "Clean Code", "Robert C. Martin", 34.99);
        Book book2 = new Book("2", "Effective Java", "Joshua Bloch", 29.99);
        bookStore.addBook(book1);
        bookStore.addBook(book2);

        // Получаем список всех книг в магазине
        List<Book> allBooks = bookStore.getAllBooks();
        for (Book book : allBooks) {
            System.out.println("Книга: " + book.getTitle() + ", Автор: " + book.getAuthor() + ", Цена: $" + book.getPrice());
        }
    }
}

```

[Реализация принципов Чистой архитектуры на Python](https://github.com/JuliaRyzhova/Software_architecture/tree/main/clean_architecture_python)


# Урок 7 (Типа архитектур WEB-приложений: MPA, SPA.)

Задание:

Описать этапы подготовки к разработке вэб-приложения, сделайть сырой макет интерфейса на figma.com

[Реализация ](https://github.com/JuliaRyzhova/Software_architecture/blob/main/web_application/README.md)


# Урок 8 (Типы архитектур прикладных приложений (мобильные): MVC, MVP, MVVM)
[Реализация паттернов на языке Java](https://github.com/JuliaRyzhova/Software_architecture/tree/main/seminar_8_java/src)

Задание:

Задание: Создание UML диаграммы классов для веб-приложения(Любого, но лучше взять за основу предыдущее)

[Реализация ](https://github.com/JuliaRyzhova/Software_architecture/blob/main/uml_diagram/README.md)